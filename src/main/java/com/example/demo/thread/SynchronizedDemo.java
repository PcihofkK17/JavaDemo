package com.example.demo.thread;

/**
 * 〈一句话功能简述〉
 * Synchronized 关键字详解
 *
 * 一：synchroinzed 原理
 *      在 java 中，每个对象 有且仅有 一个同步锁，这就证明同步锁依赖于对象存在。当我们调用某对象的 synchronized 方法时
 *  就获取到了这个对象的同步锁。不同线程的同步锁是互斥的。也就是说某个时间点内，同步锁只能被一个线程获取到。这样我我们
 *  就可以在多线程环境中，对 “对象/方法”形成互斥操作
 *
 * 二：synchroinzed 注意事项
 *  1：synchroinzed 里面使用的 this 是指当前的类对象，如果是创建了两个类的话，使用 snnchroinzed(this) 的话，不会出现阻塞行为
 *  2：当一个线程访问 synchroinzed 同步代码块的时候，其他的同步代码块会被阻塞，但是非同步代码库不会被阻塞
 *  3：如果线程访问一个类中的 synchroinzed 同步代码快的时候，该类的其他同步代码块也会被阻塞。synchroinzed(this)，
 *      因为是同一个对象锁
 *
 * 三: 同步代码块比 同步方法 更高效
 *
 * 四：实例锁和全局锁
 *  实例锁：锁在一个实例对象上的锁，如果该对象是单例的话，那么久相当于全局锁
 *      （不同的实例里面的锁的话，实例锁，那么竞争的 锁 是不同的 所以不会产生互斥）
 *  全局锁：该锁针对于类，无论该类有多少个实例对象，线程都共享这个锁
 *      （一些 static 的方法上面加锁，那么久相当于全局锁了，全部互斥）
 *
 * @author bf
 * @create 2018/2/6
 * @see [相关类/方法]（可选）
 * @since [产品/模块版本] （可选）
 */
public class SynchronizedDemo {
}
